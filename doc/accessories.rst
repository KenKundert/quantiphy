.. currentmodule:: quantiphy

.. index::
    single: accessories

.. _quantiphy_accessories:

Accessories
===========

A collection utility programs have been developed that employ *QuantiPhy* to 
enhance their functionality.  These utilities are not included as part of 
*QuantiPhy*, but are available via PyPi.


.. ec package {{{1
.. _ec package:

.. index::
   single: Engineering Calculator (ec) package

Engineering Calculator
---------------------------

`ec <https://github.com/KenKundert/ec>`_ is a handy command-line calculator for 
engineers and scientists that employs Reverse-Polish Notation (RPN) and allows 
numbers to be specified with units and SI scale factors.  With  RPN, the 
arguments are pushed onto a stack and the operators pull the needed argument 
from the stack and push the result back onto the stack.  For example, to compute 
the effective resistance of two parallel resistors:

::

    > ec
    0: 100k 50k ||
    33.333k:

And here is a fuller example that shows some of the features of *ec*. In this 
case we create initialization scripts, ~/.ecrc and ./.ecrc, and a dedicated 
script, compute-zo, and use it to compute the output impedance of a simple RC 
circuit::

    > cat ~/.ecrc
    # define some functions useful in phasor analysis
    (2pi * "rads/s")to_omega    # convert frequency in Hertz to radians/s
    (mag 2pi / "Hz")to_freq     # convert frequency in radians/s to Hertz
    (j2pi * "rads/s")to_jomega  # convert frequency in Hertz to imaginary radians/s

    > cat ./.ecrc
    # define default values for parameters
    10MHz =freq   # operating frequency
    1nF =Cin      # input capacitance
    50Ω =Rl       # load resistance

    > cat ./compute-zo
    freq to_jomega           # enter 10MHz and convert to radial freq.
    Cin * recip              # enter 1nF, multiply by 𝑥 and reciprocate
                             # to compute impedance of capacitor at 10MHz
    Rl ||                    # enter 50 Ohms and compute impedance of
                             # parallel combination
    "Ω" =Zo                  # apply units of Ω and save to Zo
    ph                       # compute the phase of impedance
    Zo mag                   # recall complex impedance from Zo and compute its magnitude
    `Zo = $0 ∠ $1 @ $freq.`  # display the magnitude and phase of Zo
    quit

    > ec compute-zo
    Zo = 15.166 Ω ∠ -72.343 degs @ 10 MHz.

    > ec 500pF =Cin compute-zo
    Zo = 26.851 Ω ∠ -57.518 degs @ 10 MHz.

It may be a bit confusing, just remember that with RPN you give the values first 
by pushing them on to the stack, and then act on them.  And once you get use to 
it, you'll likely find it quite efficient.

The source code is available from the `ec repository 
<https://github.com/KenKundert/ec>`_ on GitHub, or you can install it directly 
with::

    pip install engineering_calculator



.. tvm package {{{1
.. _tvm package:

.. index::
   single: Time-Value of Money (tvm) package

Time-Value of Money
-------------------

*Time-Value of Money* (*TVM*) is a command line program that is used to perform 
calculations involving interest rates.  It benefits from *QuantiPhy* in that it 
allows values to be given quite flexibly and concisely. The goal of the program 
is to allow you to quickly run what-if experiments involving financial 
calculations. So the fact that *QuantiPhy* allows the user to type 1.2M rather 
than 1200000 or 1.2e6 helps considerably to reach that goal.  For example, when 
running the program, this is what you would type to calculate the monthly 
payments for a mortgage::

    tvm  -p -250k -r 4.5 pmt

The program would respond with::

    pmt = $1,266.71
    pv = -$250,000.00
    fv = $0.00
    r = 4.5%
    N = 360

The act of converting strings to numbers on the way in and converting numbers to 
strings on the way out is performed by *QuantiPhy*.

*QuantiPhy* is quite flexible when it comes to converting a string to a number, 
so the present value can be given in any of the following ways: -$250k, 
-$250,000, -$2.5e5.  You can also specify the value without the currency symbol, 
which is desirable as it generally confuses the shell.

The source code is available from the `tvm repository
<https://github.com/KenKundert/tvm>`_ on GitHub, or you can install it directly 
with::

    pip install tvm



.. psf_utils package {{{1
.. _psf_utils package:

.. index::
   single: PSF Utils package

PSF Utils
---------

`PSF Utils <https://github.com/KenKundert/psf_utils>`_ is a library that allows 
you to read data from a Spectre PSF ASCII file.
Spectre is a commercial circuit simulator produced by Cadence Design Systems.
PSF files contain signals generated by Spectre.  This package also contains two
programs that are useful in their own right, but also act as demonstrators as to
how to use the library. They are *list-psf* and *plot-psf*.  The first lists the
available signals in a file, and the other displays them.

*QuantiPhy* is used by *plot-psf* when generating the axis labels.

The source code is available from the `psf_utils repository
<https://github.com/KenKundert/psf_utils>`_ on GitHub, or you can install it 
directly with::

    pip install psf_utils



.. quantiphy_eval package {{{1
.. _quantiphy_eval package:

.. index::
   single: QuantiPhy Eval package

Evaluate Expressions in Strings
-------------------------------

`QuantiPhy Eval <https://github.com/KenKundert/quantiphy_eval>`_ is yet another 
calculator, this one is a Python API that allows you to evaluate expressions 
that contain numbers with units and SI scale factors that are embedded in 
strings.

.. code-block:: python

    >>> from quantiphy_eval import evaluate

    >>> avg_price = evaluate('($1.2M + $1.3M)/2', '$')
    >>> print(avg_price)
    $1.25M

The source code is available from the `quantiphy_eval repository
<https://github.com/KenKundert/quantiphy_eval>`_ on GitHub, or you can install 
it directly with::

    pip install quantiphy_eval



.. remind package {{{1
.. _remind package:

.. index::
   single: Remind package

Schedule Reminders
------------------

`remind <https://github.com/KenKundert/remind>`_ is command line reminder 
program. At the appointed time it sends you a notification to remind you of some 
of event.  Such a program has no need for SI scale factors. Instead, this 
program uses the ability of *QuantiPhy* to scale numbers based on their units to 
provide a user-interface that takes convenient descriptions of time intervals 
such as 20m or 2h.

::

    > remind 45m remove roast from oven
    Alarm scheduled for 6:36 PM, 45 minutes from now.
    Message: remove roast from oven

You can specify the time as either a time-of-day or an elapsed time. You can 
even combine them to do simple calculations::

    > remind 10am -15m meet with Jamie
    Alarm scheduled for 9:45 AM, 108 minutes from now.
    Message: meet with Jamie

The source code is available from the `remind repository
<https://github.com/KenKundert/remind>`_ on GitHub, or you can install it 
directly with::

    pip install schedule-reminder



.. rkm codes {{{1
.. _rkm codes :

.. index::
   single: RKM codes

RKM Codes
---------

RKM codes are a way of writing numbers that is often used for specifying the 
sizes of resistors and capacitors on schematics and on the components 
themselves.  In RKM codes the radix is replaced by the scale factor and the 
units are suppressed.  Doing so results in a compact representation that is less 
likely to be misinterpreted if the number is poorly rendered.  For example, 
a 6.8KΩ could be read as 68KΩ if the decimal point is somehow lost.  The RKM 
version of 6.8KΩ is 6K8.  RKM codes are described on `Wikipedia 
<https://en.wikipedia.org/wiki/RKM_code>`_.

The popularity of RKM codes was fading because they address a problem that is 
less common today. However they are making something of a come back as all the 
characters in a RKM code are either letters or digits and so they can be 
embedded in a software identifier without introducing illegal characters.

.. code-block:: python

    >>> from rkm_codes import from_rkm, to_rkm

    >>> r = from_rkm('6K8')
    >>> r
    Quantity('6.8k')

    >>> to_rkm(r)
    '6K8'

As a practical example of the use of RKM codes, imagine wanting a program that 
creates pin names for an electrical circuit based on a naming convention where 
the pin names must be valid identifiers (must consist only of letters, digits, 
and underscores).  It would take a table of pin characteristics that are used to 
create the names.

For example::

    >>> from quantiphy import Quantity
    >>> from rkm_codes import to_rkm, set_prefs as set_rkm_prefs

    >>> pins = [
    ...     dict(kind='ibias', direction='out', polarity='sink', dest='dac', value='250nA'),
    ...     dict(kind='ibias', direction='out', polarity='src', dest='rampgen', value='2.5µA'),
    ...     dict(kind='vref', direction='out', dest='dac', value='1.25V'),
    ...     dict(kind='vdda', direction='in', value='2.5V'),
    ... ]
    >>> set_rkm_prefs(map_sf={}, units_to_rkm_base_code=None)

    >>> for pin in pins:
    ...     components = []
    ...     if 'value' in pin:
    ...         pin['VALUE'] = to_rkm(Quantity(pin['value']))
    ...     for name in ['dest', 'kind', 'direction', 'VALUE', 'polarity']:
    ...         if name in pin:
    ...             components.append(pin[name])
    ...     print('_'.join(components))
    dac_ibias_out_250n_sink
    rampgen_ibias_out_2u5_src
    dac_vref_out_1v2
    vdda_in_2v5

The source code is available from the `rkm_codes repository
<https://github.com/KenKundert/rkm_codes>`_ on GitHub, or you can install it 
directly with::

    pip install rkm_codes
