.. index::
    single: accessories

.. _accessories:

Accessories
===========

A collection utility programs have been developed that employ *QuantiPhy* to 
enhance their functionality.  These utilities are not included as part of 
*QuantiPhy*, but are available via PyPi.


.. engineering calculator package {{{1
.. _engineering calculator package:

.. index::
   single: Engineering Calculator (ec) package

ec — Engineering Calculator
---------------------------

`ec <https://github.com/KenKundert/ec>`_ is a handy command-line calculator for 
engineers and scientists that employs Reverse-Polish Notation and allows numbers 
to be specified with units and SI scale factors.

::

    > ec
    0: 100k 50k ||
    33.333k:

The source code is available from the `ec repository 
<https://github.com/KenKundert/ec>`_ on GitHub, or you can install it directly 
with::

    pip install --user engineering_calculator



.. time-value of money package {{{1
.. _time-value of money package:

.. index::
   single: Time-Value of Money (tvm) package

Time-Value of Money
-------------------

*Time-Value of Money* (*TVM*) is a command line program that is used to perform 
calculations involving interest rates.  It benefits from *QuantiPhy* in that it 
allows values to be given quite flexibly and concisely. The goal of the program 
is to allow you to quickly run what-if experiments involving financial 
calculations. So the fact that *QuantiPhy* allows the user to type 1.2M rather 
than 1200000 or 1.2e6 helps considerably to reach that goal.  For example, when 
running the program, this is what you would type to calculate the monthly 
payments for a mortgage::

    tvm  -p -250k -r 4.5 pmt

The program would respond with::

    pmt = $1,266.71
    pv = -$250,000.00
    fv = $0.00
    r = 4.5%
    N = 360

The act of converting strings to numbers on the way in and converting numbers to 
strings on the way out is performed by *QuantiPhy*.

*QuantiPhy* is quite flexible when it comes to converting a string to a number, 
so the present value can be given in any of the following ways: -$250k, 
-$250,000, -$2.5e5.  You can also specify the value without the currency symbol, 
which is desirable as it generally confuses the shell.

The source code is available from the `tvm repository
<https://github.com/KenKundert/tvm>`_ on GitHub, or you can install it directly 
with::

    pip install --user tvm



.. psf_utils package {{{1
.. _psf_utils package:

.. index::
   single: PSF Utils package

PSF Utils
---------

`PSF Utils <https://github.com/KenKundert/psf_utils>`_ is a library that allows 
you to read data from a Spectre PSF ASCII file.
Spectre is a commercial circuit simulator produced by Cadence Design Systems.
PSF files contain signals generated by Spectre.  This package also contains two
programs that are useful in their own right, but also act as demonstrators as to
how to use the library. They are *list-psf* and *plot-psf*.  The first lists the
available signals in a file, and the other displays them.

*QuantiPhy* is used by *plot-psf* when generating the axis lables.

The source code is available from the `psf_utils repository
<https://github.com/KenKundert/psf_utils>`_ on GitHub, or you can install it 
directly with::

    pip install --user psf_utils



.. quantiphy_eval package {{{1
.. _quantiphy_eval package:

.. index::
   single: QuantiPhy Eval package

QuantiPhy Eval — Evaluate Expressions in Strings
------------------------------------------------

`QuantiPhy Eval <https://github.com/KenKundert/quantiphy_eval>`_ is yet another 
calculator, this one is a Python API that allows you to evaluate expressions 
that contain numbers with units and SI scale factors that are embedded in 
strings.

.. code-block:: python

    >>> from quantiphy_eval import evaluate

    >>> avg_price = evaluate('($1.2M + $1.3M)/2', '$')
    >>> print(avg_price)
    $1.25M

The source code is available from the `quantiphy_eval repository
<https://github.com/KenKundert/quantiphy_eval>`_ on GitHub, or you can install 
it directly with::

    pip install --user quantiphy_eval



.. remind package {{{1
.. _remind package:

.. index::
   single: Remind package

remind — Schedule Reminder
--------------------------

`remind <https://github.com/KenKundert/remind>`_ is command line reminder 
program. At the appointed time it sends you a notification to remind you of some 
of event.  Such a program has no need for SI scale factors. Instead, this 
program uses the ability of *QuantiPhy* to scale numbers based on their units to 
provide a user-interface that takes convenient descriptions of time intervals 
such as 20m or 2h.

::

    > remind 45m remove roast from oven
    Alarm scheduled for 6:36 PM, 45 minutes from now.
    Message: remove roast from oven

The source code is available from the `remind repository
<https://github.com/KenKundert/remind>`_ on GitHub, or you can install it 
directly with::

    pip install --user schedule-reminder



.. rkm codes {{{1
.. _rkm codes :

.. index::
   single: RKM codes

RKM Codes Example
-----------------

RKM codes are a way of writing numbers that is often used for specifying the 
sizes of resistors and capacitors on schematics and on the components 
themselves.  In RKM codes the radix is replaced by the scale factor and the 
units are suppressed.  Doing so results in a compact representation that is less 
likely to be misinterpreted if the number is poorly rendered.  For example, 
a 6.8KΩ could be read as 68KΩ if the decimal point is somehow lost.  The RKM 
version of 6.8KΩ is 6K8.  RKM codes are described on `Wikipedia 
<https://en.wikipedia.org/wiki/RKM_code>`_.

The popularity of RKM codes was fading because they address a problem that is 
less common today. However they are making something of a come back as all the 
characters in a RKM code are either letters or digits and so they can be 
embedded in a software identifier without introducing illegal characters.

.. code-block:: python

    >>> from rkm_codes import from_rkm, to_rkm

    >>> r = from_rkm('6K8')
    >>> r
    Quantity('6.8k')

    >>> to_rkm(r)
    '6K8'

As a practical example of the use of RKM codes, imagine wanting a program that 
creates pin names for an electrical circuit based on a naming convention where 
the pin names must be valid identifiers (must consist only of letters, digits, 
and underscores).  It would take a table of pin characteristics that are used to 
create the names.

For example::

    >>> from quantiphy import Quantity
    >>> from rkm_codes import to_rkm, set_prefs as set_rkm_prefs

    >>> pins = [
    ...     dict(kind='ibias', direction='out', polarity='sink', dest='dac', value='250nA'),
    ...     dict(kind='ibias', direction='out', polarity='src', dest='rampgen', value='2.5µA'),
    ...     dict(kind='vref', direction='out', dest='dac', value='1.25V'),
    ...     dict(kind='vdda', direction='in', value='2.5V'),
    ... ]
    >>> set_rkm_prefs(map_sf={}, units_to_rkm_base_code=None)

    >>> for pin in pins:
    ...     components = []
    ...     if 'value' in pin:
    ...         pin['VALUE'] = to_rkm(Quantity(pin['value']))
    ...     for name in ['dest', 'kind', 'direction', 'VALUE', 'polarity']:
    ...         if name in pin:
    ...             components.append(pin[name])
    ...     print('_'.join(components))
    dac_ibias_out_250n_sink
    rampgen_ibias_out_2u5_src
    dac_vref_out_1v2
    vdda_in_2v5

The source code is available from the `rkm_codes repository
<https://github.com/KenKundert/rkm_codes>`_ on GitHub, or you can install it 
directly with::

    pip install --user rkm_codes
